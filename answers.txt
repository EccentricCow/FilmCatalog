______________________________________________________________________________________________________________________________________________________________________________________________________
1. Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах. Какие есть способы применения знаний о фазах распространения событий на практике?
______________________________________________________________________________________________________________________________________________________________________________________________________

Триггернем на элементе себытие. Произойдет Event Propagation в три фазы.

  1. Фаза погружения (capturing phase) — событие идёт сверху вниз (document → … → target).
  Событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., {capture: true}) (редко исп-ся).

  2. Фаза цели (target phase)
  Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.
  На второй фазе будет вызван обработчик на этом элементе.

  3. Фаза всплытия (bubbling stage)
  Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента.
  Событие будет всплывать вплоть до document (иногда - window), вызывая все обработчики на своём пути.
  Любой промежуточный обработчик может остановить всплытие через event.stopPropagation(). 

  Один из основных способов применения такого знания - дилегирование событий

  Мы навешиваем один обработчик событий на целый список (контейнер) (а если элементов 100? нельзя на каждый элемент навешать по событию). Также добавляя различные data-атрибуты можем управлять поведением отдельных элементов. 

  <ul id="list">
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>

  const ulElement = document.getElementById("list");
  ulElement.addEventListener('click', (e) => {
    if (e.target.tagName === "LI") {
      console.log(e.target.textContent);
    }
  });


______________________________________________________________________________________________________________________________________________________________________________________________________
2. Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?
______________________________________________________________________________________________________________________________________________________________________________________________________

  Promise — специальный объект в JavaScript, используется для отложенных и асинхронных вычислений. Вместо конечного результата асинхронного метода возвращается своего рода обещание получить результат в некоторый момент в будущем.
  Исполнитель (executor) запускается сразу при создании new Promise((resolve,reject)=>{...}); результат передаётся через resolve(value) или reject(error). 

  Promise может находиться в трёх состояниях:
    — ожидание (pending): начальное состояние, не исполнен и не отклонён;
    — исполнено (fulfilled): операция завершена успешно;
    — отклонено (rejected): операция завершена с ошибкой.
    Обрабатывается результат — через .then/.catch/.finally или async/await.

  Альтернативные варианты работы с асинхронным кодом:
    — коллбэки - старый как мир способ, не исспользуется из-за вероятности callback-hell;
    — async/await - синтаксический сахар над промисами - работаем как с асинхронным кодом (сделав ф-ию async), можно обернуть в try/catch;
    — различные библиотеки, например, RxJS, Axios.

  Роль EventLoop. 
    EventLoop - отдельный механизм (бпредоставляется браузером или node.js), который позволяет использовать неблокирующую модель ввода и вывода; содержит в себе task queue (которая делится на очередь микротасок и очередь макротасок).

    Основные моменты: 
  -> есть стек вызовов (за обработку которого отвечает движок JavaScript'a) 
  -> начинаем выполнять наш код сверху вниз
  -> если код синхронный: ф-ия зашла в стек, отработала, вышла (рассматриваем вариант без вложенных ф-ий)
  -> теперь летит туда асинхронная задача, например, setTimeout(). Так как это асинхронная операция, она регистрируется в браузерном WebAPI, где будет ждать своего выполнения (разрешения), после которого коллбэк (результат выполнения) этой асинхронной функции попадет в очередь тасок EventLoop'a (а точнее - в одну из очередей)
  -> далее задача из очереди выполнится только после вызова всех функций из стека (синхронного кода)

    Еще один важный момент: как EventLoop определяет, какую таску выполнить первой?
  -> асинхронщина делится на макротаски (setTimeout, setInterval, события (клик, загрузка изображения...), рендер) и микротаски (создаются промисами, queueMicrotask, mutationObserver)
  -> сначала выполняются все микротаски, потом берется 1 макротаска, потом опять все микротаски и т.д.



______________________________________________________________________________________________________________________________________________________________________________________________________
3. Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том, как ООП реализовано в JavaScript.
______________________________________________________________________________________________________________________________________________________________________________________________________

Объектно-ориентированное программирование — это паттерн, основанный на концепции различных типов объектов и их свойств.

— Рассмотрим два основных понятия ООП.
Есть у нас машина, эту машину можно охарактеризовать следующими свойствами: марка, количество колес, цвет... В контексте ООП такая характеристика называется Классом: класс Car.
Конкретный представитель класса называется Объектом, например {model: 'oka', numOfWheels: 3, color: 'eggplant'}. В контексте ООП model, numOfWheels, color - это свойства, а действия, которые может совершать объект - методами.

class Car {
  model;
  numOfWheels;
  color;
  engineOn;

  constructor(model, numOfWheels, color) {                    // также у класса есть конструктор - блок инструкций
    this.model = model;
    this.numOfWheels = numOfWheels;
    this.color = color;
  }

  acceleration() {    
    this.numOfWheels -= 1;  
    console.log(`${this.model} accelerates, there are ${this.numOfWheels} wheels left`);
  }

  startEngine() {    this.engineOn = true;  }
  stopEngine() {    this.engineOn = false;  }
}

const neighbourCar = new Car('oka', 3, 'eggplant');                   // создаем объект
neighbourCar.acceleration()                   // можем вызвать соответствующий метод


— Три основные концепции ООП: инкапсуляция, наследование, полиморфизм

1. Принцип инкапсуляции: класс является капсулой, которая содержит в себе свойства и методы для работы с этими свойствами. Рядом с инкапсуляцией шагает сокрытие: есть доступные извне данные (открытые миру), есть недоступные - выставляем это с помощью модификаторов доступа.
  Для нашего класса Car примем: мы можем посмотреть цвет, модель, посчитать колеса, растолкать бричку с горки - это все публичные свойства. Но вот завести ее у нас не выйдет. Поэтому простовить модификаторы доступа можем следующим образом:

  class Car {
    model;
    numOfWheels;
    color;
    _engineOn;                    // с ES6 можно исп-ть # - обратиться к приватному свойству/методу извне не получится; для TS: public, protected (angular), private

    constructor(model, numOfWheels, color) {                      
      this.model = model;
      this.numOfWheels = numOfWheels;
      this.color = color;
    }

    acceleration() {    
      this.numOfWheels -= 1;  
      console.log(`${this.model} accelerates, there are ${this.numOfWheels} wheels left`);
    }

    _startEngine() {    this._engineOn = true;  }
    _stopEngine() {    this._engineOn = false;  }
  }

  Также можно использовать геттеры и сеттеры для получения/обновления данных (например, если нам нужна какая-то проверка перед обновлением данных).

2. Принцип наследования - повторное использование кода/поведение от родителя. В JS это прототипная цепочка; синтаксис class — удобный «синтаксический сахар» над прототипами.

  class RacingCar extends Car {                   // принимаем свойства и методы класса Car
    exhaustVolume; 

    constructor(model, numOfWheels, color, exhaustVolume) {     
      super(model, numOfWheels, color);                // в первую очередь вызовется родительский конструктор (класса Car) 
      this.exhaustVolume = exhaustVolume;  
    }
  }

  const neighbourRacingCar = new RacingCar('oka', 4, 'yellow', 170);  
  console.log(neighbourRacingCar.model)                   

3. Принциа полиморфизма - единый интерфейс, разные реализации (переопределение методов в дочерних классах). 
  Полиморфизм выделяют мнимый и параметрический.
    — ad-hoc полиморфимз - приведение типов
    — параметрический
    Переопределим метод acceleration() для RacingCar, тогда:
    class RacingCar extends Car {                   // принимаем свойства и методы класса Car
      exhaustVolume; 

      constructor(model, numOfWheels, color, exhaustVolume) {     
        super(model, numOfWheels, color);                // в первую очередь вызовется родительский конструктор (класса Car) 
        this.exhaustVolume = exhaustVolume;  
      }

      acceleration() {    
        console.log(`${this.model} accelerates, there are ${this.numOfWheels} wheels left`);
      }
    }

  const carList = [neighbourCar, neighbourRacingCar];                    // явным образом не указываем, что у нас массив Car и еще RacingCar
  carList.forEach((car) => car.acceleration());                     // acceleration() отработает по-разному

        Также взаимодействие м/у классами может быть осуществленно через композицию или агрегацию.
        — Композиция исп-ся, когда объект жестко связан с владельцем:

        class Engine {
          start() { console.log('engine started'); }
        }

        class Car {
          constructor() {
            this.engine = new Engine();                   // Engine — часть Car, без машины двигатель не существует
          }
          drive() {
            this.engine.start();
            console.log('car driving');
          }
        }

        — Агрегация - один класс содержит ссылку на другой, но тот может существовать отдельно.
        class Driver {
          constructor(name) { this.name = name; }
        }

        class Car {
          constructor(driver) {
            this.driver = driver;                     // Driver существует сам по себе, и может управлять другой машиной.
          }
        }

— Как ООП реализовано в JavaScript?


JavaScript довольно ограничен в плане инструментов для работы в ООП-стиле. Под капотом - прототипы и прототипное наследование - объекты делегируют поведение другим объектам через внутреннее поле [[Prototype]], 
получается своеобразная прототипная цепочка — последовательность объектов, по которой движется поиск свойства: сначала собственные свойства объекта, затем его прототип, затем прототип прототипа и т.д., пока не встретится null.

Если метод помещать в this внутри конструктора — каждая инстанция получит свою копию метода (память и лишние аллокации). Лучше:

function Person(name){ this.name = name; }
Person.prototype.say = function(){ return `Hi ${this.name}`; };
const p = new Person('Al');                   // p → Person.prototype → Object.prototype
                    // Тогда все инстанции будут делить один объект метода.

ES6 class — удобный синтаксис для читаемости - в купе с паттернами проектирования создают хорошую базу для ООП.



______________________________________________________________________________________________________________________________________________________________________________________________________
4. Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопастность, междоменное взаимодействие) могут 
возникать в процессе?
______________________________________________________________________________________________________________________________________________________________________________________________________

парсится URL -> браузер понимает, что это не поисковый запрос а домен -> ищет ip этого домена в разных кешах, до которых может дотянуться -> если нет, то формируется DNS-запрос, который отправляется на DNS-сервер -> DNS-сервер возвращает ip, который браузер сохраняет в кеше -> 
-> когда ip известен, формируется TCP-соединение через 3х-стороннее рукопожатие -> обмен флагами -> GET запрос за HTML (в зависимости от типа рендера SSR/SSG/CSR дальнейшее поведение немного отличаться) -> клиент получает HTML (при SSR/SSG это уже с DOM-ом, дальше происходит процесс 
гидратации - "оживление" страницы JS-кодом), для СSR - это пустая страница, делаются запросы за скриптами и стилями -> строится DOM-дерево и CSSOM-дерево -> строится render-tree -> стадия layout'a -> стадия отрисовки -> стадия composition (распределение по слоям) 

Ускорить процесс можно за счет:
 — SSR (рендеринг на стороне сервера - как в данном проекте) и SSG (на сервере лежит кипа HTML, которые отдаются пользователю),
 — использования preload, preconnect,
 — tiny ims,
 — для шрифтов woff2 (или запрос с preconnect)
 — ускорить hydration исп-ем @defer, уменьшением основного клиентского бандла, уменьшением статики, пропуском всего того, что не нужно серверу (например, вычисление computed)

Проблемы безопасности:
— CORS - браузерное ограничение, чтобы какой-нибудь мошеннический сайт не смог сделать запрос за реальными данными какого-то другого приложения и вывести их у себя на сайте (для этого ограничиваются кросс-доменные запросы - в основном регулируется на стороне бэкенда - бэкенд определяет, 
с каких доменов можно делать запросы на а с каких - нет, регулируется с помощью handler'ов): в данном проекте были переписаны ручки, потому что Vercel блокировал запросы c tg/safari.
— Загрузка ресурсов по HTTP с HTTPS-страницы блокируется или понижается в приоритете.